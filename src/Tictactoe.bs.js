// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_math = require("rescript/lib/js/js_math.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Js_array = require("rescript/lib/js/js_array.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");

function init(param) {
  return {
          board: [
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ],
            [
              0,
              0,
              0
            ]
          ],
          move: 1,
          winnerCoords: []
        };
}

var state = init(undefined);

var toCheck = [
  [
    0,
    1,
    2
  ],
  [
    3,
    4,
    5
  ],
  [
    6,
    7,
    8
  ],
  [
    0,
    3,
    6
  ],
  [
    1,
    4,
    7
  ],
  [
    2,
    5,
    8
  ],
  [
    2,
    4,
    6
  ],
  [
    0,
    4,
    8
  ]
];

var coords = [
  [
    [
      0,
      0
    ],
    [
      0,
      1
    ],
    [
      0,
      2
    ]
  ],
  [
    [
      1,
      0
    ],
    [
      1,
      1
    ],
    [
      1,
      2
    ]
  ],
  [
    [
      2,
      0
    ],
    [
      2,
      1
    ],
    [
      2,
      2
    ]
  ],
  [
    [
      0,
      0
    ],
    [
      1,
      0
    ],
    [
      2,
      0
    ]
  ],
  [
    [
      0,
      1
    ],
    [
      1,
      1
    ],
    [
      2,
      1
    ]
  ],
  [
    [
      0,
      2
    ],
    [
      1,
      2
    ],
    [
      2,
      2
    ]
  ],
  [
    [
      0,
      2
    ],
    [
      1,
      1
    ],
    [
      2,
      0
    ]
  ],
  [
    [
      0,
      0
    ],
    [
      1,
      1
    ],
    [
      2,
      2
    ]
  ]
];

function freePos(s) {
  var fp = [];
  Belt_Array.forEachWithIndex(s, (function (i, x) {
          Belt_Array.forEachWithIndex(x, (function (j, y) {
                  if (y === 0) {
                    Js_array.push([
                          i,
                          j
                        ], fp);
                    return ;
                  }
                  
                }));
        }));
  return fp;
}

function areSame(r) {
  var a = r[0];
  var b = r[1];
  var c = r[2];
  if (a === b && b === c && a === c) {
    return a > 0;
  } else {
    return false;
  }
}

function check(m) {
  var s = m.board;
  var row = [];
  Belt_Array.forEachWithIndex(s, (function (param, x) {
          Belt_Array.forEachWithIndex(x, (function (param, y) {
                  Js_array.push(y, row);
                }));
        }));
  var a = Belt_Array.map(toCheck, (function (x) {
          var e1 = x[0];
          var e2 = x[1];
          var e3 = x[2];
          return areSame([
                      row[e1],
                      row[e2],
                      row[e3]
                    ]);
        }));
  var opt = Belt_Array.getIndexBy(a, (function (x) {
          return x;
        }));
  var ind = Belt_Option.getWithDefault(opt, -1);
  if (ind >= 0) {
    return Belt_Array.get(coords, ind);
  }
  
}

function nextCoords(fp) {
  var l = fp.length;
  if (l === 0) {
    return ;
  }
  var r = Js_math.random_int(0, l);
  return Belt_Array.get(fp, r);
}

function nextMove(m) {
  if (m.move === 1) {
    return 2;
  } else {
    return 1;
  }
}

function isTerminal(m) {
  var s = m.board;
  var b = Belt_Array.reduce(s, true, (function (x, y) {
          var rv = Belt_Array.reduce(y, true, (function (p, q) {
                  if (p) {
                    return q !== 0;
                  } else {
                    return false;
                  }
                }));
          if (x) {
            return rv;
          } else {
            return false;
          }
        }));
  if (m.winnerCoords.length !== 0) {
    return true;
  } else {
    return b;
  }
}

function utility(m) {
  if (m.winnerCoords.length === 0) {
    return 0;
  }
  var match = m.winnerCoords[0];
  var row = m.board[match[0]];
  var v = row[match[1]];
  if (v === 1) {
    return 1;
  } else {
    return -1;
  }
}

function freePosToState(pos, s, value) {
  var q = pos[1];
  var p = pos[0];
  return Belt_Array.mapWithIndex(s, (function (i, x) {
                return Belt_Array.mapWithIndex(x, (function (j, y) {
                              if (i === p && q === j) {
                                return value;
                              } else {
                                return y;
                              }
                            }));
              }));
}

function minValue(m) {
  if (isTerminal(m)) {
    return [
            utility(m),
            undefined
          ];
  }
  var fp = freePos(m.board);
  var models = Belt_Array.map(fp, (function (x) {
          var nm = nextMove(m);
          var s = freePosToState(x, m.board, nm);
          var newModel_winnerCoords = m.winnerCoords;
          var newModel = {
            board: s,
            move: nm,
            winnerCoords: newModel_winnerCoords
          };
          var opt = check(newModel);
          var sameCoords = Belt_Option.getWithDefault(opt, []);
          var model = {
            board: s,
            move: nm,
            winnerCoords: sameCoords
          };
          var match = maxValue(model);
          return [
                  match[0],
                  x
                ];
        }));
  var match = Belt_Array.reduce(models, [
        1000,
        undefined
      ], (function (a, b) {
          var v2 = b[0];
          var v1 = a[0];
          if (v1 < v2) {
            return [
                    v1,
                    a[1]
                  ];
          } else {
            return [
                    v2,
                    b[1]
                  ];
          }
        }));
  return [
          match[0],
          match[1]
        ];
}

function maxValue(m) {
  if (isTerminal(m)) {
    return [
            utility(m),
            undefined
          ];
  }
  var fp = freePos(m.board);
  var models = Belt_Array.map(fp, (function (x) {
          var nm = nextMove(m);
          var s = freePosToState(x, m.board, nm);
          var newModel_winnerCoords = m.winnerCoords;
          var newModel = {
            board: s,
            move: nm,
            winnerCoords: newModel_winnerCoords
          };
          var opt = check(newModel);
          var sameCoords = Belt_Option.getWithDefault(opt, []);
          var model = {
            board: s,
            move: nm,
            winnerCoords: sameCoords
          };
          var match = minValue(model);
          return [
                  match[0],
                  x
                ];
        }));
  var match = Belt_Array.reduce(models, [
        -1000,
        undefined
      ], (function (a, b) {
          var v2 = b[0];
          var v1 = a[0];
          if (v1 > v2) {
            return [
                    v1,
                    a[1]
                  ];
          } else {
            return [
                    v2,
                    b[1]
                  ];
          }
        }));
  return [
          match[0],
          match[1]
        ];
}

function minimaxSearch(m) {
  var match = maxValue(m);
  return Belt_Option.getWithDefault(match[1], [
              -1,
              -1
            ]);
}

function update(_model, _msg) {
  while(true) {
    var msg = _msg;
    var model = _model;
    var winnerCoords = model.winnerCoords;
    if (winnerCoords.length !== 0) {
      if (msg) {
        return model;
      } else {
        return init(undefined);
      }
    }
    if (!msg) {
      return init(undefined);
    }
    var j = msg._1;
    var i = msg._0;
    var s = Belt_Array.mapWithIndex(model.board, (function(model,i,j){
        return function (n, x) {
          return Belt_Array.mapWithIndex(x, (function (m, y) {
                        var p = nextMove(model);
                        if (n === i && m === j) {
                          return p;
                        } else {
                          return y;
                        }
                      }));
        }
        }(model,i,j)));
    var nm = nextMove(model);
    var newModel_winnerCoords = model.winnerCoords;
    var newModel = {
      board: s,
      move: nm,
      winnerCoords: newModel_winnerCoords
    };
    var opt = check(newModel);
    var sameCoords = Belt_Option.getWithDefault(opt, []);
    if (nm === 1) {
      return {
              board: s,
              move: nm,
              winnerCoords: sameCoords
            };
    }
    if (nm !== 2) {
      return {
              board: s,
              move: nm,
              winnerCoords: sameCoords
            };
    }
    var match = minimaxSearch(newModel);
    var y = match[1];
    var x = match[0];
    if (Caml_obj.equal([
            x,
            y
          ], [
            -1,
            -1
          ])) {
      return {
              board: s,
              move: nm,
              winnerCoords: sameCoords
            };
    }
    var newModel$1 = {
      board: s,
      move: nm,
      winnerCoords: sameCoords
    };
    _msg = /* Coords */{
      _0: x,
      _1: y
    };
    _model = newModel$1;
    continue ;
  };
}

function cellStyle(i, j, m, value) {
  var wc = m.winnerCoords;
  var style = value === 2 ? "cross" : "circle";
  if (Js_array.findIndex((function (x) {
            return Caml_obj.equal(x, [
                        i,
                        j
                      ]);
          }), wc) >= 0) {
    return "winner " + style + "";
  } else {
    return style;
  }
}

exports.init = init;
exports.state = state;
exports.toCheck = toCheck;
exports.coords = coords;
exports.freePos = freePos;
exports.areSame = areSame;
exports.check = check;
exports.nextCoords = nextCoords;
exports.nextMove = nextMove;
exports.isTerminal = isTerminal;
exports.utility = utility;
exports.freePosToState = freePosToState;
exports.minValue = minValue;
exports.maxValue = maxValue;
exports.minimaxSearch = minimaxSearch;
exports.update = update;
exports.cellStyle = cellStyle;
/* state Not a pure module */
